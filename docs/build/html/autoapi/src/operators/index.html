
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>src.operators &#8212; DGCG algorithm 0.0.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="../../../index.html">
          <span>DGCG algorithm 0.0.1 documentation</span></a></h1>
        <h2 class="heading"><span>src.operators</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="module-src.operators">
<span id="src-operators"></span><h1><a class="reference internal" href="#module-src.operators" title="src.operators"><code class="xref py py-mod docutils literal notranslate"><span class="pre">src.operators</span></code></a><a class="headerlink" href="#module-src.operators" title="Permalink to this headline">¶</a></h1>
<p>Methods related to the problem’s forward operator and Hilbert spaces.</p>
<p>The Hilbert spaces are implicitly defined via the functons in this module.
A priory, these are numpy.ndarray of type complex objects, representing a
finite dimensional complex space.</p>
<p>This module has certain global variables to be used by the defined methods.
These are set by <a class="reference internal" href="../DGCG/index.html#src.DGCG.set_model_parameters" title="src.DGCG.set_model_parameters"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.DGCG.set_model_parameters()</span></code></a></p>
<div class="section" id="global-variables">
<h2>Global variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>test_func<span class="classifier">callable</span></dt><dd><p>Function representing the kernel that defines the forward operator.</p>
</dd>
<dt>grad_test_func<span class="classifier">callable</span></dt><dd><p>Derivative function of test_func</p>
</dd>
<dt>H_dimensions<span class="classifier">list[int]</span></dt><dd><p>Dimensions of each of the considered Hilbert spaces.</p>
</dd>
</dl>
</div>
<div class="section" id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Permalink to this headline">¶</a></h2>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.operators.H_t_product" title="src.operators.H_t_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H_t_product</span></code></a>(t, f_t, g_t)</p></td>
<td><p>Computes the Hilbert space product between two elements in <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.operators.H_t_product_set_vector" title="src.operators.H_t_product_set_vector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H_t_product_set_vector</span></code></a>(t, f_t, g_t)</p></td>
<td><p>Hilbert space product between a set of elements vs a single one.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.operators.int_time_H_t_product" title="src.operators.int_time_H_t_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">int_time_H_t_product</span></code></a>(f, g)</p></td>
<td><p>Time integral of two collections of elements in each Hilbert space.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.operators.K_t" title="src.operators.K_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_t</span></code></a>(t, f_t)</p></td>
<td><p>Evaluation of pre-adjoint forward operator of the inverse problem.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.operators.grad_K_t" title="src.operators.grad_K_t"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grad_K_t</span></code></a>(t, f)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.operators.K_t_star" title="src.operators.K_t_star"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_t_star</span></code></a>(t, rho)</p></td>
<td><p>Evaluation of forward operator of the inverse problem.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.operators.K_t_star_full" title="src.operators.K_t_star_full"><code class="xref py py-obj docutils literal notranslate"><span class="pre">K_t_star_full</span></code></a>(rho)</p></td>
<td><p>Evaluation of forward operator of the inverse problem at all times.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.operators.overpenalization" title="src.operators.overpenalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overpenalization</span></code></a>(s, M_0)</p></td>
<td><p>Overpenalization of the main inverse problem energy.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.operators.main_energy" title="src.operators.main_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">main_energy</span></code></a>(rho, f)</p></td>
<td><p>The main energy to minimize by the inverse problem.</p></td>
</tr>
</tbody>
</table>
<dl class="py data">
<dt id="src.operators.TEST_FUNC">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">TEST_FUNC</code><a class="headerlink" href="#src.operators.TEST_FUNC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="src.operators.GRAD_TEST_FUNC">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">GRAD_TEST_FUNC</code><a class="headerlink" href="#src.operators.GRAD_TEST_FUNC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt id="src.operators.H_DIMENSIONS">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">H_DIMENSIONS</code><a class="headerlink" href="#src.operators.H_DIMENSIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.H_t_product">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">H_t_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em>, <em class="sig-param"><span class="n">g_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.H_t_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Hilbert space product between two elements in <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">H_t</span></code> represents the Hilbert space at time <code class="docutils literal notranslate"><span class="pre">t</span></code>. The implemented
Hilbert space consists of the normalized real part of the complex dot
product</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the referenced time sample. Takes values in 0,1,…,T. With
(T+1) the total number of time samples.</p>
</dd>
<dt><strong>f_t, g_t</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>1-dimenisonal complex array representing an element of the Hilbert
space at time <code class="docutils literal notranslate"><span class="pre">t</span></code>, <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The computed formula is</p>
<div class="math">
<p><img src="../../../_images/math/82df5b3d3078616104536c0a988a20d937d0a874.png" alt="&lt;f_t,g_t&gt;_{H_t} = Re(&lt;f_t, g_t&gt;_{\mathbb{C}})/dim(H_t)
= Re( \sum_k f_t(k)\overline g_t(k))/dim(H_t)"/></p>
</div><p>The Hilbert spaces must be real, meaning that the output of the inner
product has to be a real number. In the implemented case here, we
considered realified complex spaces.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.H_t_product_set_vector">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">H_t_product_set_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em>, <em class="sig-param"><span class="n">g_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.H_t_product_set_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Hilbert space product between a set of elements vs a single one.</p>
<p>An extension for fast evaluation between groups of elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the references time sample. Takes values in 0,1,…,T, where
(T+1) the total number of time samples.</p>
</dd>
<dt><strong>f_t</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(N,K) shaped complex array representing a collection of <code class="docutils literal notranslate"><span class="pre">N</span></code>  elements
of the Hilbert space at time <code class="docutils literal notranslate"><span class="pre">t</span></code> <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/> with dimension <code class="docutils literal notranslate"><span class="pre">K</span></code>.</p>
</dd>
<dt><strong>g_t</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>1-dimensional complex array representing an element of the Hilbert
space at time t <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(N,1)-dimensional float array with <code class="docutils literal notranslate"><span class="pre">N</span></code> the number of elements of the
input collection <code class="docutils literal notranslate"><span class="pre">f_t</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.operators.int_time_H_t_product">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">int_time_H_t_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.int_time_H_t_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Time integral of two collections of elements in each Hilbert space.</p>
<p>A time integral in this context corresponds to the time average. Therefore
this method computes the time average of the Hilbert space inner products.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>f,g</strong><span class="classifier">list[numpy.ndarray]</span></dt><dd><p>A list of size <code class="docutils literal notranslate"><span class="pre">T</span></code>, where the <code class="docutils literal notranslate"><span class="pre">t-th</span></code> entry contains an element of
the Hilbert space at time <code class="docutils literal notranslate"><span class="pre">t</span></code>, <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Precisely, the computed value is</p>
<div class="math">
<p><img src="../../../_images/math/4ef8161908849cf790ee22d97bb2c58ae46f42ff.png" alt="\sum_{t=0}^T w(t) &lt;f_t, g_t&gt;_{H_t}"/></p>
</div><p>with <img class="math" src="../../../_images/math/3a1b440be273b1f496c4b4ff451a385254e47d97.png" alt="w(t)"/> some weight at time <img class="math" src="../../../_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, by default it is
<img class="math" src="../../../_images/math/8044029ffd248040856390b747df19d74d355da9.png" alt="1/T"/>, with <img class="math" src="../../../_images/math/e8dea8254118f111b5fb20895b03528c17566f06.png" alt="T"/> the total number of time samples.
To change the way the spaces are weighted in this integral, modify
<code class="docutils literal notranslate"><span class="pre">config.time_weights</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.K_t">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluation of pre-adjoint forward operator of the inverse problem.</p>
<p>Defines/evaluates the preadjoint of the forward operator at time sample
<code class="docutils literal notranslate"><span class="pre">t</span></code> and element <code class="docutils literal notranslate"><span class="pre">f</span></code> of the t-th Hilbert space. The preadjoint maps into
continuous functions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the considered time sample. Takes values from 0,1,…,T-1</p>
</dd>
<dt><strong>f</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>1-dimensional complex array representing a member of the t-th Hilbert
space <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>callable[numpy.ndarray, numpy.ndarray]</dt><dd><p>function that takes (N,2)-sized arrays represnting <code class="docutils literal notranslate"><span class="pre">N</span></code> points in
the domain Ω, and returns a (N,1)-sized array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The preadjoint at time sample <img class="math" src="../../../_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is a function that maps from the
Hilbert space <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/> to the space of continuous functions on the
domain <img class="math" src="../../../_images/math/32f233d300b80bd0bb51f5be3985ccc9db1af510.png" alt="C(\Omega)"/>. The formula that defines this mapping is</p>
<div class="math">
<p><img src="../../../_images/math/516abae34497e124238bf7814e5ee2ddedd2fe7a.png" alt="K_t(f_f) = x \rightarrow &lt;\varphi(t,x), f_t&gt;_{H_t}"/></p>
</div><p>With <img class="math" src="../../../_images/math/ed710ddac707fcbc540bfe7b354ca2d900f0faa0.png" alt="\varphi"/> the function <code class="docutils literal notranslate"><span class="pre">TEST_FUNC</span></code> input via
<a class="reference internal" href="../DGCG/index.html#src.DGCG.set_model_parameters" title="src.DGCG.set_model_parameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.DGCG.set_model_parameters</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.grad_K_t">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">grad_K_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.grad_K_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.K_t_star">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t_star</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluation of forward operator of the inverse problem.</p>
<p>Evaluates the forward operator at time
sample <code class="docutils literal notranslate"><span class="pre">t</span></code> and measure <code class="docutils literal notranslate"><span class="pre">rho</span></code>. The forward operator at time <code class="docutils literal notranslate"><span class="pre">t</span></code>
maps into the t-th Hilbert space <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the considered time sample. Takes values from 0,1,…,T, where
(T+1) is the total number of time samples of the inverse problem.</p>
</dd>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="../classes/index.html#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>Measure where the forward operator is evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>1-dimensional complex array, representing an element of the t-th
Hilbert space <code class="docutils literal notranslate"><span class="pre">H_t</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The forward operator at time sample <img class="math" src="../../../_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/> is a function that maps
from the space of Radon measures <img class="math" src="../../../_images/math/9ab68886bfb971bd684de85e3609157384bcc847.png" alt="\mathcal{M}(\Omega)"/> to the
<img class="math" src="../../../_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>-th Hilbert space <img class="math" src="../../../_images/math/59e4e87af6be295ae6e78aab6c56040234c23a4f.png" alt="H_t"/>. The input measure of class
<a class="reference internal" href="../classes/index.html#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a> is a dynamic measure, that once evaluated
at time <img class="math" src="../../../_images/math/907a4add6d5db5b7f197f7924f1371b8ac404fe6.png" alt="t"/>, becomes a Radon Measure.</p>
<p>The formula that defines this function is the following Bochner integral</p>
<div class="math">
<p><img src="../../../_images/math/551fc66d7a4386e9c3f6dabbb36d2a705b572956.png" alt="K_t^*(\rho_t) = \int_{\Omega} \varphi(t,x) \rho_t(dx)"/></p>
</div><p>With <img class="math" src="../../../_images/math/ed710ddac707fcbc540bfe7b354ca2d900f0faa0.png" alt="\varphi"/> the function <code class="docutils literal notranslate"><span class="pre">TEST_FUNC</span></code> input via
<a class="reference internal" href="../DGCG/index.html#src.DGCG.set_model_parameters" title="src.DGCG.set_model_parameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.DGCG.set_model_parameters</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.K_t_star_full">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t_star_full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t_star_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluation of forward operator of the inverse problem at all times.</p>
<p>Evaluates the forward operator at all time
samples and dynamic measure <code class="docutils literal notranslate"><span class="pre">rho</span></code>. The output of this method is a list
of elements in <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>rho</strong><span class="classifier"><a class="reference internal" href="../classes/index.html#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>Measure where the forward operator is evaluated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list[numpy.ndarray]</dt><dd><p>T-sized list of 1-dimensional complex arrays, representing elements
of the Hilbert spaces <code class="docutils literal notranslate"><span class="pre">H_t</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For further reference, see <a class="reference internal" href="#src.operators.K_t_star" title="src.operators.K_t_star"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.operators.K_t_star()</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.overpenalization">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">overpenalization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">M_0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.overpenalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Overpenalization of the main inverse problem energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s, M_0</strong><span class="classifier">float</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is the one applied to the Benamou-Brenier energy when
defining the surrogate linear problem described in the paper. It is a
<img class="math" src="../../../_images/math/1ce3bb635dc0009cb422aaf4a41b0ebbd70e52c2.png" alt="C^1"/> gluing of a linear and quadratic function.</p>
</dd></dl>

<dl class="py function">
<dt id="src.operators.main_energy">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">main_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.main_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>The main energy to minimize by the inverse problem.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>measure</strong><span class="classifier"><a class="reference internal" href="../classes/index.html#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>Radon measure.</p>
</dd>
<dt><strong>f</strong><span class="classifier">list[numpy.ndarray]</span></dt><dd><p>list of elements of the Hilbert spaces <code class="docutils literal notranslate"><span class="pre">H_t</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Implements the formula</p>
<div class="math">
<p><img src="../../../_images/math/c56869e31b48baef9302de648f313c4f78013067.png" alt="\frac{1}{2T} \sum_{t=0}^{T-1} || K_t^*(\rho_t) - f_t ||_{H_t}^2 +
J_{\alpha, \beta}(\rho, m)"/></p>
</div><p>Where <img class="math" src="../../../_images/math/e9bc7da808d33a16a8347f27a519bd067186aa66.png" alt="m"/> is the momentum, that is implicitly defined for sparse
measures as the ones used here.</p>
</dd></dl>

</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, K. Bredies, M. Carioni, S. Fanzon, F. Romero-Hinrichsen.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>