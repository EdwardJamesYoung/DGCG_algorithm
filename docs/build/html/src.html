
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>src package &#8212; DGCG algorithm 0.0.1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
      <div class="header" role="banner"><h1 class="heading"><a href="index.html">
          <span>DGCG algorithm 0.0.1 documentation</span></a></h1>
        <h2 class="heading"><span>src package</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content" role="main">
        
        
  <div class="section" id="src-package">
<h1>src package<a class="headerlink" href="#src-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-src.DGCG">
<span id="src-dgcg-module"></span><h2>src.DGCG module<a class="headerlink" href="#module-src.DGCG" title="Permalink to this headline">¶</a></h2>
<p>General controller of the DGCG algorithm package.</p>
<dl class="py function">
<dt id="src.DGCG.set_model_parameters">
<code class="sig-prename descclassname">src.DGCG.</code><code class="sig-name descname">set_model_parameters</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">alpha</span></em>, <em class="sig-param"><span class="n">beta</span></em>, <em class="sig-param"><span class="n">time_samples</span></em>, <em class="sig-param"><span class="n">H_dimensions</span></em>, <em class="sig-param"><span class="n">test_func</span></em>, <em class="sig-param"><span class="n">grad_test_func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.DGCG.set_model_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the the fundamental parameters of the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>alpha, beta: float</strong></dt><dd><p>Regularization parameter of the regularization problem, must be
positive.</p>
</dd>
<dt><strong>time_samples: numpy.ndarray</strong></dt><dd><p>Ordered array of values between 0 and 1, with <code class="docutils literal notranslate"><span class="pre">time_samples[0]</span> <span class="pre">=</span> <span class="pre">0</span></code>
and <code class="docutils literal notranslate"><span class="pre">time_samples[-1]</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>H_dimension: list[int]</strong></dt><dd><p>List of dimensions of the considered Hilbert spaces <code class="docutils literal notranslate"><span class="pre">H_t</span></code>.</p>
</dd>
<dt><strong>test_func</strong><span class="classifier">callable[[int, numpy.ndarray], numpy.ndarray]</span></dt><dd><p>Function φ that defines the forward measurements. The first input
is time, the second input is a list of elements in the domain Ω. It
maps into a list of elements in H_t. See Notes for further reference.</p>
</dd>
<dt><strong>grad_test_func</strong><span class="classifier">callable[[int, numpy.ndarray], numpy.ndarray]</span></dt><dd><p>The gradient of the input function <cite>test_func</cite>. The inputs of the
gradient are the same of those of the original function.
Returns a tuple with each partial derivative.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is required to set this values prior to defining atoms or taking
measurements. This is because the input values fix the set of extremal
points of the Benomou-Brenier energy, and the given kernels define the
Forward and Backward measurement operators.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">test_func</span></code> φ is the funciton that defines the forward measurements.
The first input is a time sample in <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">T-1]</span></code>, with <code class="docutils literal notranslate"><span class="pre">T</span></code> the
total number of time samples. The second input is a list of <code class="docutils literal notranslate"><span class="pre">N</span></code> elements
in Ω, expressed as a (N,2) <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> (Ω is of dimension 2).</p>
<p>The output of φ is a list of <code class="docutils literal notranslate"><span class="pre">N</span></code> elements in <code class="docutils literal notranslate"><span class="pre">H_t</span></code>, since the
dimension of <code class="docutils literal notranslate"><span class="pre">H_t</span></code> is input with <code class="docutils literal notranslate"><span class="pre">H_dimensions</span></code>, then the output
of φ(t, x) is a (N, H_dimensions[t]) <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
<p>The function <code class="docutils literal notranslate"><span class="pre">grad_test_func</span></code> ∇φ has the same input, but the output is
a (2, N, H_dimensions[t]) tuple representing the two partial derivatives
∂_x and ∂_y respectively.</p>
</dd></dl>

<dl class="py function">
<dt id="src.DGCG.solve">
<code class="sig-prename descclassname">src.DGCG.</code><code class="sig-name descname">solve</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.DGCG.solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the given dynamic inverse problem for input data.</p>
<p>This function will apply the Dynamic Generalized Conditional Gradient
(DGCG) algorithm.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of <code class="docutils literal notranslate"><span class="pre">T</span></code> entries, each a numpy.ndarray of size <code class="docutils literal notranslate"><span class="pre">H_dimensions[t]</span></code>
for each <code class="docutils literal notranslate"><span class="pre">t</span></code>. See notes for further reference.</p>
</dd>
<dt><strong>initial_measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a>, optional</span></dt><dd><p>Initial guess for the DGCG algorithm. Default value is <cite>None</cite>
corresponding the the zero measure.</p>
</dd>
<dt><strong>use_ffmmpeg</strong><span class="classifier">bool, optional</span></dt><dd><p>To indicate the use of the <cite>ffmpeg</cite> library. If set to false,
matplotlib won’t be able to save the output videos as videos files.
Nonetheless, it is possible to animate the measures with the
<cite>DGCG.classes.measure.animate</cite> method.</p>
</dd>
<dt><strong>insertion_max_restarts</strong><span class="classifier">int, optional</span></dt><dd><p>Hard limit on the number of allowed restarts for the multistart
gradient descent at each iteration. Default 1000.</p>
</dd>
<dt><strong>insertion_min_restarts</strong><span class="classifier">int, optional</span></dt><dd><p>Hard limit on the number of allowed restarts for the multistart
gradient descent at each iteration. Default 20.</p>
</dd>
<dt><strong>results_folder</strong><span class="classifier">str, optional</span></dt><dd><p>name of the folder that will be created to save the simulation
results. Default ‘results’.</p>
</dd>
<dt><strong>multistart_early_stop</strong><span class="classifier">callable[[int,int], int] optional</span></dt><dd><p>function to stop early as a function of the found stationary points.
Default lambda n,m: np.inf.</p>
</dd>
<dt><strong>multistart_pooling_num</strong><span class="classifier">int, optional</span></dt><dd><p>When insertion random curves, the algorithm will realize this given
number of curves and then choose the one with best F(γ) value.
The higher the value of this parameter, the more one
samples on the best initial curves to descent. The drawback
is that it slows down the proposition of random curves.</p>
</dd>
<dt><strong>log_output</strong><span class="classifier">bool, optional</span></dt><dd><p>Save the output of shell into a .txt inside the results folder.
default False, to be improved. &lt;+TODO+&gt;</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>solution</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>The computed solution.</p>
</dd>
<dt><strong>exit_flag</strong><span class="classifier">tuple[int, str]</span></dt><dd><p>Tuple with a numeric indicator and a string with a brief description.
&lt;+TODO+&gt; check this, add dual_gap exit value.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The <code class="docutils literal notranslate"><span class="pre">data</span></code> input corresponds to the gathered data with the defined
forward operator when running <a class="reference internal" href="#src.DGCG.set_model_parameters" title="src.DGCG.set_model_parameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">src.DGCG.set_model_parameters()</span></code></a>.
Each entry of this array correspond to the measurement at each time sample.
Therefore, the size of that entry will correspond to the respective <code class="docutils literal notranslate"><span class="pre">H_t</span></code>
space.</p>
</dd></dl>

</div>
<div class="section" id="module-src.checker">
<span id="src-checker-module"></span><h2>src.checker module<a class="headerlink" href="#module-src.checker" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="src.checker.H_t_product">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">H_t_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em>, <em class="sig-param"><span class="n">g_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.H_t_product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.H_t_product_full">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">H_t_product_full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.H_t_product_full" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.is_in_H">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">is_in_H</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.is_in_H" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.is_in_H_t">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">is_in_H_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.is_in_H_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.is_in_space_domain">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">is_in_space_domain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.is_in_space_domain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.is_valid_time">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">is_valid_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.is_valid_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.checker.set_in_H_t">
<code class="sig-prename descclassname">src.checker.</code><code class="sig-name descname">set_in_H_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.checker.set_in_H_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-src.config">
<span id="src-config-module"></span><h2>src.config module<a class="headerlink" href="#module-src.config" title="Permalink to this headline">¶</a></h2>
<p>General configuration file.</p>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>This module contains all the configuration parameters that define the details
of the DGCG algorithm. Al parameters are set at execution of <cite>DGCG.solve</cite>
and then remain fixed.</p>
</div>
<div class="section" id="members">
<h3>Members<a class="headerlink" href="#members" title="Permalink to this headline">¶</a></h3>
<dl>
<dt><strong>results_folder</strong><span class="classifier">str, default ‘results’</span></dt><dd><p>By default, the algorithm stores at each iteration the iterate, graphs
the convergence plots, dual gaps, found stationary points, etc.
This variable indicates the name of the folder in which these are stored.</p>
</dd>
<dt><strong>logger</strong><span class="classifier"><a class="reference internal" href="autoapi/src/log_mod/index.html#src.log_mod.logger" title="src.log_mod.logger"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.log_mod.logger</span></code></a>, default None</span></dt><dd><p>The logger class is involved in all the logging activities, like plotting,
pickling data, terminal printing, etc. A logger object is created and then
accessed by all the modules here via <cite>config.logger</cite>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">int, default 51</span></dt><dd><p>The number of time samples of the problem.</p>
</dd>
<dt><strong>time</strong><span class="classifier">numpy.ndarray, default np.linspace(0, 1, T)</span></dt><dd><p>The respective time samples of the problem.</p>
</dd>
<dt><strong>time_weights</strong><span class="classifier">numpy.ndarray, default np.ones(T)/T</span></dt><dd><p>The associated weights to each time sample. By default, these are equally
weighted summing up to 1. Relevant when dealing with different uncertainty
values for each time sample.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, default 0.1</span></dt><dd><p>Regularization coefficient of the problem</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, default 0.1</span></dt><dd><p>Regularization coefficient of the problem</p>
</dd>
<dt><strong>f_t</strong><span class="classifier">list[numpy.ndarray], default None</span></dt><dd><p>Input data in the problem, represents a list of elements in H_t for each t.</p>
</dd>
<dt><strong>measure_coefficient_too_low</strong><span class="classifier">float, default 1e-18</span></dt><dd><p>The measure class is a weighted sum of atoms. When the weight of an
atom is lower than this threshold, it is automatically discarded.</p>
</dd>
<dt><strong>full_max_iteration</strong><span class="classifier">int, default 1000</span></dt><dd><p>Maximum number of iterations of the algorithm.</p>
</dd>
<dt><strong>insertion_max_segments</strong><span class="classifier">int, default 20</span></dt><dd><p>In the insertion step, during the multistart gradient descent, random
curves are proposed for descense in insertion_mod.random_insertion
The number of segments of the random curves is chosen at random, with
this parameter defining the upper limit on the chosen segments.</p>
</dd>
<dt><strong>rejection_sampling_epsilon</strong><span class="classifier">float, default 0.05</span></dt><dd><p>When generating random curves for insertion at
insertion_mod.random_insertion, once the time nodes of the curve is
defined, the spatial positions are chosed via the rejection_sampling
algorithm. This parameter is involved in the definition of used function.
In principle, the higher is this number, the faster the rejection sampling
algorithm will find a candidate. But simultaneously, it will miss possible
candidates that have values barely above 0.</p>
</dd>
<dt><strong>insertion_length_bound_factor</strong><span class="classifier">float, default 1.1</span></dt><dd><p>When proposing curves to descend in insertion_mod.propose, it is known
from the theory that any solution must not exceed a certain length that
can be computed. If any proposed curve surpases this limit by a factor
given by this parameter, it is automatically discarded.</p>
</dd>
<dt><strong>multistart_pooling_number</strong><span class="classifier">int, default 1000</span></dt><dd><p>When proposing random curves, many random curves are proposed and
afterwards, before descending them, we choose the best one from this group
The size of the generated random curves is defined by this parameter.
The criteria to choose the best curve is one that has the least F(γ) value.</p>
</dd>
<dt><strong>crossover_consecutive_inserts</strong><span class="classifier">int, default 30</span></dt><dd><p>The proposing method at insertion_mod.propose switches between choosing
a crossover curve or a random curve. For each N crossover propositions
it does 1 random proposition. N here corresponds to this parameter.</p>
</dd>
<dt><strong>crossover_search_attempts</strong><span class="classifier">int, default 1000</span></dt><dd><p>To crossover curves the algorithm must look for curves that are close
enough to crossover and then check if these have been crossover beforehand.
This information is contained in the sort-of-dictionary object
insertion_mod.ordered_list_of_lists, and to look for new pairs it will
randomly access the entries to see if a crossover can be obtained.
It will attempt this random entries the number given by the his parameters,
if no crossover is found after this search, insertion_mod.propose will
declare that there are no available crossovers and then will propose a
random curve for descent.</p>
</dd>
<dt><strong>crossover_child_F_threshold</strong><span class="classifier">float, default 0.8</span></dt><dd><p>Obtained crossover curves will be proposed for descensen only if their
energy F(γ) is close to the best known stationary curve. How close it has
to be is modulated by this parameter, it must satisfy
F(crossover_child) &lt; crossover_child_F_threshold * F(best_curve),
remember that the energies are negative.</p>
</dd>
<dt><strong>crossover_max_distance</strong>: float, default 0.05</dt><dd><p>Childs from two curves can be obtained only if at some point in time they
get close one to another, this parameter indicates how close they need to
get in H^1 norm for a crossover to happen.</p>
</dd>
<dt><strong>insertion_eps</strong><span class="classifier">float, default 1e-10</span></dt><dd><p>This is the tolenrance value to stop the algorithm. If the dual gap drops
below it, the algorithm exits.</p>
</dd>
<dt><strong>insertion_max_restarts</strong><span class="classifier">int, default 20</span></dt><dd><p>The maximum number of restarts of the multistart algorithm.</p>
</dd>
<dt><strong>insertion_min_restarts</strong><span class="classifier">int, default 15</span></dt><dd><p>The minimum number of restarts of the multistart algorithm. This
parameter is useful only in the case an early stop criteria is set
via the <cite>multistart_early_stop</cite> parameter.</p>
</dd>
<dt><strong>multistart_inter_iteration_checkup</strong><span class="classifier">int, default 50</span></dt><dd><p>While descending a single curve during the multistart gradient descent,
the code will routinely check if curve being descended is close to the any
element of the stationary point set. If so, the descense is stopped
and the curve is discarded. This parameter regulates how often this
check is done. Precaution: The algorithm also is coded to “omit” the curves
that got too fast too close to the stationary point set. By “omiting”, we
mean that such a descented curve will not count towards the number of
descented curves; “too fast” means that the curve got too close to the
statonary set before the first checkup. A consequence of this is that if
this checkup number is set too high, and there are a few stationary points,
then  (almost) all the descended curves will converge faster than the first
checkup and as such, they will not count towards the number of attempted
tries. Heavily slowing down the algorithm.</p>
</dd>
<dt><strong>multistart_max_discarded_tries</strong><span class="classifier">int, default 30</span></dt><dd><p>If more than multistart_max_discarded_tries curves are discarded
consecutively. Then the algorithm will issue a warning to set
<cite>multistart_inter_iteration_checkup</cite> higher and will add a counter
to the number of restarts. This is a failsafe against a <cite>while true</cite> loop.</p>
</dd>
<dt><strong>multistart_taboo_dist</strong><span class="classifier">float, default 0.01</span></dt><dd><p>The distance, in H^1 norm, of a curve to an element of the stationary
set to be discarded.</p>
</dd>
<dt><strong>multistart_energy_dist</strong><span class="classifier">float, default 0.01</span></dt><dd><p>Acceleration parameter to measure the distance between the descended curve
with those of the stationary set. The stationary point set is ordered by
their F(γ) value, which is also readily available in a list. Therefore by
computing the F(γ) value of the descended curve, one can just compare the
current curve with those around that value, this parameter defines that
radius.</p>
</dd>
</dl>
<p><strong>multistart_early_stop</strong> : callable[[int,int], int], default constant equal to
infinite</p>
<blockquote>
<div><p>This parameter allows to pass an early stop criteria to the multistart
algorithm. The input is a two variable function whose first input is
the number of attempted restarts, and the second parameter is the number
of found stationary point. The multistart gradient descent will stop once
it either reaches the <cite>insertion_max_restart</cite> value, or the value given by
this function.</p>
</div></blockquote>
<dl class="simple">
<dt><strong>multistart_proposition_max_iter</strong><span class="classifier">int, default 10000</span></dt><dd><p>Each proposed curve must start with negative energy, if it does not, it
is discarded and another curve is proposed. This parameter sets a limit on
how many attempts will be done.</p>
</dd>
<dt><strong>multistart_descent_max_iter</strong><span class="classifier">int, default 16000</span></dt><dd><p>This parameter limits the number of gradient descent steps that will be
done on each descended curve.</p>
</dd>
<dt><strong>multistart_descent_soft_max_iter</strong><span class="classifier">int, default 5000</span></dt><dd><p>This is a soft maximum number of iterations. If the currently descended
curve has done more than this number of iterations, and simultaneously its
energy is not “good enough”, then the descense will be stopped.</p>
</dd>
<dt><strong>multistart_descent_soft_max_threshold</strong><span class="classifier">float, default 0.8</span></dt><dd><p>Sets the threshold to discard the current descended curve, the current
descended curve has to be at least this ratio closer to the best known
stationary curve.</p>
</dd>
<dt><strong>multistart_descent_init_step</strong><span class="classifier">float, default 1</span></dt><dd><p>The gradient descent uses an Armijo with backtracking descent. This
parameter sets the intiial stepsize/</p>
</dd>
<dt><strong>multistart_descent_limit_stepsize</strong><span class="classifier">float, default 1e-20</span></dt><dd><p>The gradient descent stops when the stepsize becomes smaller than this
value.</p>
</dd>
<dt><strong>H1_tolerance</strong><span class="classifier">float, default 1e-5</span></dt><dd><p>The quadratic optimization step will attempt to merge curves that are
closer than this distance in H1 norm.</p>
</dd>
<dt><strong>curves_list_length_lim</strong><span class="classifier">int, default 1000</span></dt><dd><p>The quadratic optimization step will take at most this number of stationary
point found in the insertion step.</p>
</dd>
<dt><strong>curves_list_length_min</strong><span class="classifier">int, default 10,</span></dt><dd><p>In the optimization step after the insertion step, the inserted curves are
the union of the already known curves, together with those found in the
multistart descent. This parameter sets least number of stationary curves
from the mutlistart descent that have to be added for optimization.</p>
</dd>
<dt><strong>CVXOPT_TOL</strong><span class="classifier">float, default 1e-25</span></dt><dd><p>CVXOPT is the used solver to tackle the quadratic optimization step. This
parameter defines the considered tolerance value for both the relative and
absolute errors.</p>
</dd>
<dt><strong>g_flow_opt_max_iter</strong><span class="classifier">int, default 100000</span></dt><dd><p>During the sliding step, this parameter modules the maximum number of
iterations to execute.</p>
</dd>
<dt><strong>g_flow_opt_in_between_iters</strong><span class="classifier">int, default 100</span></dt><dd><p>During the sliding step, in between iterations, the weights of the measure
are optomized via the optimization step. This parameter regulates how often
this is done.</p>
</dd>
<dt><strong>g_flow_init_step</strong><span class="classifier">float, default 1</span></dt><dd><p>The initial stepsize of the Armijo with Backtracking gradient descent
for the Sliding step.</p>
</dd>
<dt><strong>g_flow_limit_stepsize</strong><span class="classifier">float, defaylt 1e-20</span></dt><dd><p>During the sliding step, the descent stops once the stepsize reaches this
size.</p>
</dd>
<dt><strong>log_output</strong><span class="classifier">bool, default False</span></dt><dd><p>Switch to log the convergence information into a .txt file into the
<cite>results</cite> folder. WARNING: requires rework, too many useless lines are
saved.</p>
</dd>
<dt><strong>save_output_each_N</strong><span class="classifier">int, default 1000</span></dt><dd><p>How often the saved logs will be saved. This parameter consider the number
of lines of the file.</p>
</dd>
<dt><strong>log_maximal_line_size</strong><span class="classifier">int, default 10000,</span></dt><dd><p>Maximum size of the logfile. If exceeded, the file is discarded.</p>
</dd>
<dt><strong>use_ffmpeg</strong><span class="classifier">bool, default True</span></dt><dd><p>Switch to use the ffmpeg library. This is required to save the obtained
curves and measures as videos.</p>
</dd>
</dl>
<dl class="py function">
<dt id="src.config.multistart_early_stop">
<code class="sig-prename descclassname">src.config.</code><code class="sig-name descname">multistart_early_stop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">num_tries</span></em>, <em class="sig-param"><span class="n">num_found</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.config.multistart_early_stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.config.self_pickle">
<code class="sig-prename descclassname">src.config.</code><code class="sig-name descname">self_pickle</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.config.self_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to pickle and save the variables in this module.</p>
<p>In general, one could just look at this file to know the parameters. In
practice, one will modify these values on the fly using the DGCG controler.
Therefore it is better to have a method to read and save these settings
automatically right before execution.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-src.classes">
<span id="src-classes-module"></span><h2>src.classes module<a class="headerlink" href="#module-src.classes" title="Permalink to this headline">¶</a></h2>
<p>Container of the used classes of the module.</p>
<dl class="py class">
<dt id="src.classes.curve">
<em class="property">class </em><code class="sig-prename descclassname">src.classes.</code><code class="sig-name descname">curve</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Piecewise linear continuous curves in the domain Ω.</p>
<p>To There are two ways to initialize a curve. Either input a single
numpy.ndarray of size (T,2), representing a set of <code class="docutils literal notranslate"><span class="pre">T</span></code> spatial points,
the produced curve will take N uniformly taken time samples.</p>
<p>Alternative, initialize with two arguments, the first one a one dimentional
ordered list of time samples of size T, and a set of corresponding
numpy.ndarray of size (T,2).</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>spatial_points</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(T,2) sized array with <code class="docutils literal notranslate"><span class="pre">T</span></code> the number of time samples. Corresponds to
the position of the curve at each time sample.</p>
</dd>
<dt><strong>time_samples</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(T,) sized array corresponding to each time sample.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve.H1_norm" title="src.classes.curve.H1_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H1_norm</span></code></a>()</p></td>
<td><p>Computes the <code class="docutils literal notranslate"><span class="pre">H^1</span></code> norm of this curve.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.curve.H1_seminorm" title="src.classes.curve.H1_seminorm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H1_seminorm</span></code></a>()</p></td>
<td><p>Computes the <code class="docutils literal notranslate"><span class="pre">H^1</span></code> seminorm of the curve</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve.L2_norm" title="src.classes.curve.L2_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">L2_norm</span></code></a>()</p></td>
<td><p>Computes the <code class="docutils literal notranslate"><span class="pre">L^2</span></code> norm of the curve</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.curve.draw" title="src.classes.curve.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw</span></code></a>([tf, ax, color, plot])</p></td>
<td><p>Method to draw the curve.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve.energy" title="src.classes.curve.energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">energy</span></code></a>()</p></td>
<td><p>Computes the Benamou-Brenier with Total variation energy.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.curve.eval" title="src.classes.curve.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(t)</p></td>
<td><p>Evaluate the curve at a certain time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve.eval_discrete" title="src.classes.curve.eval_discrete"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval_discrete</span></code></a>(t)</p></td>
<td><p>Evaluate the curve at a certain time node.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.curve.integrate_against" title="src.classes.curve.integrate_against"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate_against</span></code></a>(w_t)</p></td>
<td><p>Method to integrate a dual variable along this curve.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve.set_times" title="src.classes.curve.set_times"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_times</span></code></a>(new_times)</p></td>
<td><p>Method to change the <code class="docutils literal notranslate"><span class="pre">time_samples</span></code> member,</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.classes.curve.H1_norm">
<code class="sig-name descname">H1_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.H1_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <code class="docutils literal notranslate"><span class="pre">H^1</span></code> norm of this curve.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.H1_seminorm">
<code class="sig-name descname">H1_seminorm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.H1_seminorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <code class="docutils literal notranslate"><span class="pre">H^1</span></code> seminorm of the curve</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.L2_norm">
<code class="sig-name descname">L2_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.L2_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the <code class="docutils literal notranslate"><span class="pre">L^2</span></code> norm of the curve</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.draw">
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tf</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">color</span><span class="o">=</span><span class="default_value">[0.0, 0.5, 1.0]</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to draw the curve.</p>
<p>Using <cite>matplotlib.collections.LineCollection</cite>, this method draws the
curve as a collection of segments, whose transparency indicates the
time of the drawn curve. It also returns the segments and their
respective colors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>tf</strong><span class="classifier">float, optional</span></dt><dd><p>value in (0,1] indicating until which time the curve will be drawn.
Default 1.</p>
</dd>
<dt><strong>ax</strong><span class="classifier">matplotlib.axes.Axes, optional</span></dt><dd><p>An axes object to which to include the drawing of the curve.
Default None</p>
</dd>
<dt><strong>color</strong><span class="classifier">list[float], optional</span></dt><dd><p>Length-3 list of the RGB color to give to the curve. Default
[0.0, 0.5, 1.0]</p>
</dd>
<dt><strong>plot</strong><span class="classifier">bool, optional</span></dt><dd><p>Switch to draw or not the curve.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.axes.Axes</span></dt><dd><p>The axes with the drawn curve</p>
</dd>
<dt><strong>segments_colors</strong><span class="classifier">(numpy.ndarray, numpy.ndarray)</span></dt><dd><p>A tuple with the segments describing the curve on the first entry,
and the RGBA colors of them in the second entry</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.energy">
<code class="sig-name descname">energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Benamou-Brenier with Total variation energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the curve at a certain time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">list[float] or float</span></dt><dd><p>time values in <code class="docutils literal notranslate"><span class="pre">[0,1]</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>positions</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(N,2) sized array representing <code class="docutils literal notranslate"><span class="pre">N</span></code> different points in <code class="docutils literal notranslate"><span class="pre">R^2</span></code>.
<code class="docutils literal notranslate"><span class="pre">N</span></code> corresponds to the number of input times.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.eval_discrete">
<code class="sig-name descname">eval_discrete</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.eval_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the curve at a certain time node.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>The selected time sample, in 0,1,…,T-1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A single spatial point represented by a (1,2) array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.integrate_against">
<code class="sig-name descname">integrate_against</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.integrate_against" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to integrate a dual variable along this curve.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd><p>The dual variable to integrate against</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>The integral of w_t along the curve.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve.set_times">
<code class="sig-name descname">set_times</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_times</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve.set_times" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to change the <code class="docutils literal notranslate"><span class="pre">time_samples</span></code> member,</p>
<p>It changes the vector of time samples by adjusting accordingly the
<code class="docutils literal notranslate"><span class="pre">spatial_points</span></code> member,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_times</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>1 dimensional array with new times to have the curvee defined in.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="src.classes.curve_product">
<em class="property">class </em><code class="sig-prename descclassname">src.classes.</code><code class="sig-name descname">curve_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve_list</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Elements of a weighted product space of curve type objects.</p>
<p>It can be initialized with empty arguments, or via the keyworded arguments
<cite>curve_list</cite> and <cite>weights</cite>.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>weights</strong><span class="classifier">list[float]</span></dt><dd><p>Positive weights associated to each space.</p>
</dd>
<dt><strong>curves</strong><span class="classifier">list[<a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a>]</span></dt><dd><p>List of curves</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.curve_product.H1_norm" title="src.classes.curve_product.H1_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">H1_norm</span></code></a>()</p></td>
<td><p>Computes the weighted product <img class="math" src="_images/math/8edcd76aefbd5c6ec60e63bfb5a521444943f8a0.png" alt="H^1"/> norm.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.curve_product.to_measure" title="src.classes.curve_product.to_measure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_measure</span></code></a>()</p></td>
<td><p>Cast this objet into <a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.classes.curve_product.H1_norm">
<code class="sig-name descname">H1_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve_product.H1_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the weighted product <img class="math" src="_images/math/8edcd76aefbd5c6ec60e63bfb5a521444943f8a0.png" alt="H^1"/> norm.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.curve_product.to_measure">
<code class="sig-name descname">to_measure</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.curve_product.to_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast this objet into <a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="src.classes.dual_variable">
<em class="property">class </em><code class="sig-prename descclassname">src.classes.</code><code class="sig-name descname">dual_variable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Dual variable class.</p>
<p>The dual variable is obtained from both the current iterate and the
problem’s input data. The data can be fetched from <code class="docutils literal notranslate"><span class="pre">config.f_t</span></code>.</p>
<p>To initialize, call dual_variable(current_measure) with <code class="docutils literal notranslate"><span class="pre">current_measure</span></code>
a <a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.dual_variable.animate" title="src.classes.dual_variable.animate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">animate</span></code></a>([measure, resolution, filename, …])</p></td>
<td><p>Animate the dual variable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.dual_variable.as_density_eval" title="src.classes.dual_variable.as_density_eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_density_eval</span></code></a>(t, x)</p></td>
<td><p>Evaluate the density obtained from the dual variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.dual_variable.as_density_get_params" title="src.classes.dual_variable.as_density_get_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_density_get_params</span></code></a>(t)</p></td>
<td><p>Return the parameters to use the dual variable as density.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.dual_variable.eval" title="src.classes.dual_variable.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a>(t, x)</p></td>
<td><p>Evaluate the dual variable in a time and space</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.dual_variable.get_sum_maxs" title="src.classes.dual_variable.get_sum_maxs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sum_maxs</span></code></a>()</p></td>
<td><p>Output the sum of the maxima of the dual variable at each time.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.dual_variable.grad_eval" title="src.classes.dual_variable.grad_eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grad_eval</span></code></a>(t, x)</p></td>
<td><p>Evaluate the gradient of the dual variable in a time and space</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.dual_variable.grid_evaluate" title="src.classes.dual_variable.grid_evaluate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">grid_evaluate</span></code></a>(t[, resolution])</p></td>
<td><p>Evaluates the dual variable in a spatial grid for a fixed time.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.classes.dual_variable.animate">
<code class="sig-name descname">animate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">resolution</span><span class="o">=</span><span class="default_value">0.01</span></em>, <em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">block</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.animate" title="Permalink to this definition">¶</a></dt>
<dd><p>Animate the dual variable.</p>
<p>This function uses matplotlib.animation.FuncAnimation to create an
animation representing the dual variable. Since the dual variable
is a continuous function in Ω, it can be represented by evaluating
it in some grid and plotting this in time.
This method also supports a measure class input, to be overlayed on top
of this animation. This option is helpful if one wants to see the
current iterate <img class="math" src="_images/math/92d3672bbd4c8a50dc63f1b5fac1bcd11fc61aa8.png" alt="\mu^n"/> overlayed on its dual variable,
the solution curve of the insertion step or, at the first iteration,
the backprojection of the data with the ground truth overlayed.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a>, optional</span></dt><dd><p>Measure to be overlayed into the animation. Defaults to None.</p>
</dd>
<dt><strong>resolution</strong><span class="classifier">float, optional</span></dt><dd><p>Resolution of the grid in which the dual variable would be
evaluated. Defaults to 0.01.</p>
</dd>
<dt><strong>filename</strong><span class="classifier">str, optional</span></dt><dd><p>If given, will save the output to a file &lt;filename&gt;.mp4.
Defaults to None.</p>
</dd>
<dt><strong>show</strong><span class="classifier">bool, default True</span></dt><dd><p>Switch to indicate if the animation should be shown.</p>
</dd>
<dt><strong>block</strong><span class="classifier">bool, default False</span></dt><dd><p>Switch to indicate if the animation should pause the execution.
Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>matplotlib.animation.FuncAnimation</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The method returns a FuncAnimation object because it is
required by matplotlib, else the garbage collector will eat it up and
no animation would display. Reference:
<a class="reference external" href="https://stackoverflow.com/questions/48188615/funcanimation-doesnt-show-outside-of-function">https://stackoverflow.com/questions/48188615/funcanimation-doesnt-show-outside-of-function</a></p>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.as_density_eval">
<code class="sig-name descname">as_density_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.as_density_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the density obtained from the dual variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the time samples, with vales in 0,1,…,T-1</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>(1,2) array of floats representing a point in the domain Ω.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.as_density_get_params">
<code class="sig-name descname">as_density_get_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.as_density_get_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the parameters to use the dual variable as density.</p>
<p>This method is useful for the rejection sampling algorithm. See
<a class="reference internal" href="#src.insertion_mod.rejection_sampling" title="src.insertion_mod.rejection_sampling"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.insertion_mod.rejection_sampling()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of the time samples, with values in 0,1,…,T-1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>density_support</strong><span class="classifier">float</span></dt><dd><p>Proportion of the sampled pixels where the density is non-zero
at the given time t.</p>
</dd>
<dt><strong>density_max</strong><span class="classifier">float</span></dt><dd><p>Maximum value of the density at the given time t.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the dual variable in a time and space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Time sample index, takes values in 0,1,…,T-1</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>(N,2) sized array representing ``N`` spatial points of the domain Ω.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(N,1) sized array, corresponding to the evaluations in the N given
points at a fixed time.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.get_sum_maxs">
<code class="sig-name descname">get_sum_maxs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.get_sum_maxs" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the sum of the maxima of the dual variable at each time.</p>
<p>This quantity is useful to discard random curves that have too high
initial-speed/Benamou-Brenier energy.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.grad_eval">
<code class="sig-name descname">grad_eval</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.grad_eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the gradient of the dual variable in a time and space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Time sample index, takes values in 0,1,…,T-1</p>
</dd>
<dt><strong>x</strong><span class="classifier">numpy.ndarray</span></dt><dd></dd>
<dt><strong>(N,2) sized array representing ``N`` spatial points of the domain Ω.</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>(2,N,1) sized array, corresponding to the evaluations in the N
given points at a fixed time, and the first coordinate indicating
the partial derivatives.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.dual_variable.grid_evaluate">
<code class="sig-name descname">grid_evaluate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">resolution</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.dual_variable.grid_evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the dual variable in a spatial grid for a fixed time.</p>
<p>The grid is uniform in [0,1]x[0,1]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of time sample, takes values in 0,1,…,T-1</p>
</dd>
<dt><strong>resolution</strong><span class="classifier">float, optional</span></dt><dd><p>Resolution of the spatial grid. Defaults to 0.01</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>evaluations</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Square float array of evaluations.</p>
</dd>
<dt><strong>maximum_at_t</strong><span class="classifier">float</span></dt><dd><p>Maximum value of the dual variable in this grid at time t.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt id="src.classes.measure">
<em class="property">class </em><code class="sig-prename descclassname">src.classes.</code><code class="sig-name descname">measure</code><a class="headerlink" href="#src.classes.measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Sparse measures composed of a finite weighted sum of Atoms.</p>
<p>Initializes with empty arguments to create the zero measure.</p>
<p class="rubric">Notes</p>
<p>As described in the theory, an Atom is a Dirac delta on a curve with a
respective weight. This weight is defined by 1/energy of the curve.</p>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>curves</strong><span class="classifier">list[<a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a>]</span></dt><dd><p>List of member curves.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of positive weights associated to each curve.</p>
</dd>
<dt><strong>energies</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Array of stored Benamou-Brenier energies associated to each curve.
See <a class="reference internal" href="#src.classes.curve.energy" title="src.classes.curve.energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.classes.curve.energy()</span></code></a>.</p>
</dd>
<dt><strong>main_energy</strong><span class="classifier">float</span></dt><dd><p>The Tikhonov energy of the measure.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.measure.add" title="src.classes.measure.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(new_curve, new_weight)</p></td>
<td><p>Include a new curve with associated weight into the measure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.measure.animate" title="src.classes.measure.animate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">animate</span></code></a>([filename, show, block])</p></td>
<td><p>Method to create an animation representing the measure object.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.measure.draw" title="src.classes.measure.draw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">draw</span></code></a>([ax])</p></td>
<td><p>Draws the measure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.measure.get_main_energy" title="src.classes.measure.get_main_energy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_main_energy</span></code></a>()</p></td>
<td><p>Computes the Tikhonov energy of the Measure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.measure.integrate_against" title="src.classes.measure.integrate_against"><code class="xref py py-obj docutils literal notranslate"><span class="pre">integrate_against</span></code></a>(w_t)</p></td>
<td><p>Integrates the measure against a dual variable.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.measure.modify_weight" title="src.classes.measure.modify_weight"><code class="xref py py-obj docutils literal notranslate"><span class="pre">modify_weight</span></code></a>(curve_index, new_weight)</p></td>
<td><p>Modifies the weight of a particular Atom/curve</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.measure.reorder" title="src.classes.measure.reorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder</span></code></a>()</p></td>
<td><p>Reorders the curves and weights of the measure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.classes.measure.spatial_integrate" title="src.classes.measure.spatial_integrate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spatial_integrate</span></code></a>(t, target)</p></td>
<td><p>Spatially integrates the measure against a function for fixed time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.classes.measure.to_curve_product" title="src.classes.measure.to_curve_product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_curve_product</span></code></a>()</p></td>
<td><p>Casts the measure into a <a class="reference internal" href="#src.classes.curve_product" title="src.classes.curve_product"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve_product</span></code></a>.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.classes.measure.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_curve</span></em>, <em class="sig-param"><span class="n">new_weight</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Include a new curve with associated weight into the measure.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>new_curve</strong><span class="classifier"><a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a></span></dt><dd><p>Curve to be added.</p>
</dd>
<dt><strong>new_weight</strong><span class="classifier">float</span></dt><dd><p>Positive weight to be added.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.animate">
<code class="sig-name descname">animate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filename</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">show</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">block</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.animate" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to create an animation representing the measure object.</p>
<p>Uses <code class="docutils literal notranslate"><span class="pre">matplotlib.animation.FuncAnimation</span></code> to create a video
representing the measure object, where each curve, and its respective
intensity is represented. The curves are ploted on time, and the color
of the curve represents the respective intensity.  It is possible to
output the animation to a <code class="docutils literal notranslate"><span class="pre">.mp4</span></code> file if <code class="docutils literal notranslate"><span class="pre">ffmpeg</span></code> is available.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str, optional</span></dt><dd><p>A string to save the animation as <code class="docutils literal notranslate"><span class="pre">.mp4</span></code> file. Default None
(no video is saved).</p>
</dd>
<dt><strong>show</strong><span class="classifier">bool, optional</span></dt><dd><p>Switch to indicate if the animation should be immediately shown.
Default True.</p>
</dd>
<dt><strong>frames</strong><span class="classifier">int, optional</span></dt><dd><p>Number of frames considered in the animation. Default 51.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.draw">
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">ax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws the measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ax</strong><span class="classifier">matplotlib.axes.Axes, optional</span></dt><dd><p>axes to include the drawing. Defaults to None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>matplotlib.axes.Axes</dt><dd><p>The modified, or new, axis with the drawing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.get_main_energy">
<code class="sig-name descname">get_main_energy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.get_main_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the Tikhonov energy of the Measure.</p>
<p>It also stores it as a member of the measure.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.integrate_against">
<code class="sig-name descname">integrate_against</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.integrate_against" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates the measure against a dual variable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.modify_weight">
<code class="sig-name descname">modify_weight</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve_index</span></em>, <em class="sig-param"><span class="n">new_weight</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.modify_weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the weight of a particular Atom/curve</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>curve_index</strong><span class="classifier">int</span></dt><dd><p>Index of the target curve stored in the measure.</p>
</dd>
<dt><strong>new_weight</strong><span class="classifier">float</span></dt><dd><p>Positive new weight.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.reorder">
<code class="sig-name descname">reorder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.reorder" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorders the curves and weights of the measure.</p>
<p>Reorders the elements such that they have increasing intensity.
The intensity is defined as <code class="docutils literal notranslate"><span class="pre">intensity</span> <span class="pre">=</span> <span class="pre">weight/energy</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.spatial_integrate">
<code class="sig-name descname">spatial_integrate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">target</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.spatial_integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially integrates the measure against a function for fixed time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of time sample in <code class="docutils literal notranslate"><span class="pre">0,1,...,T-1</span></code>.</p>
</dd>
<dt><strong>target</strong><span class="classifier">callable[numpy.ndarray, float]</span></dt><dd><p>A function that takes values on the 2-dimensional domain and
returns a real number.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.classes.measure.to_curve_product">
<code class="sig-name descname">to_curve_product</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.classes.measure.to_curve_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts the measure into a <a class="reference internal" href="#src.classes.curve_product" title="src.classes.curve_product"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve_product</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-src.insertion_mod">
<span id="src-insertion-mod-module"></span><h2>src.insertion_mod module<a class="headerlink" href="#module-src.insertion_mod" title="Permalink to this headline">¶</a></h2>
<p>Module to handle the proposed inserted curves to be descended.</p>
<p>The module exhibits <code class="docutils literal notranslate"><span class="pre">global</span></code> variables that are used to remember the
state of the insertion step.</p>
<div class="section" id="global-variables">
<h3>Global variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h3>
<dl>
<dt><strong>known_curves</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code>]</span></dt><dd><p>List of member curves from the current iterate of the DGCG algorithm that
have not yet been descended.</p>
</dd>
<dt><strong>crossover_memory</strong><span class="classifier"><a class="reference internal" href="#src.insertion_mod.ordered_list_of_lists" title="src.insertion_mod.ordered_list_of_lists"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.insertion_mod.ordered_list_of_lists</span></code></a></span></dt><dd><p>Object that keeps track of the crossover information between
the found stationary curves.</p>
</dd>
<dt><strong>cycling_iter</strong><span class="classifier">iterator</span></dt><dd><p>Cycling iterator that keeps track on the number of consecutive crossover
curves that have been proposed.</p>
</dd>
</dl>
<dl class="py function">
<dt id="src.insertion_mod.crossover">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">crossover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve1</span></em>, <em class="sig-param"><span class="n">curve2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.crossover" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain all the crossovers between two curves.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>curve1, curve2</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd><p>Curve to crossover.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>list[<code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code>]</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To obtain a crossover, a minimum distance threshold is set by
<code class="docutils literal notranslate"><span class="pre">config.crossover_max_distance</span></code>. Then for every time these curves
get closer than this and then separate, two new crossover curves are
obtained.</p>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.find_crossover">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">find_crossover</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">stationary_curves</span></em>, <em class="sig-param"><span class="n">energy_curves</span></em>, <em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.find_crossover" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a crossover curve to propose from the list of stationary curves.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>stationary_curves</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code>]</span></dt><dd><p>List of found stationary curves.</p>
</dd>
<dt><strong>energy_curves</strong><span class="classifier">numpy.array</span></dt><dd><p>1-dimensional array of respective energies of the stationary curves.</p>
</dd>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a>.</span></dt><dd><p>Dual variable associated to the current iterate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code> or None</dt><dd><p>If a crossover is found, returns it. If not, returns None.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.initialize">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">initialize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the global variables at the beggining of each insertion step.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>current_measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>The current iterate of the DGCG algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="src.insertion_mod.ordered_list_of_lists">
<em class="property">class </em><code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">ordered_list_of_lists</code><a class="headerlink" href="#src.insertion_mod.ordered_list_of_lists" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Class to organize the found stationary curves and executed crossovers.</p>
<p>Initializes with no arguments into an empty list of lists.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">list[list[tuple[list[int], int]]]</span></dt><dd><p>A list of size <code class="docutils literal notranslate"><span class="pre">M</span></code>, the number of known stationary curves, which at
the entry <code class="docutils literal notranslate"><span class="pre">i</span></code> contains a list of size <code class="docutils literal notranslate"><span class="pre">M-i-1</span></code>. For <code class="docutils literal notranslate"><span class="pre">i&lt;j</span></code>, The
entry <code class="docutils literal notranslate"><span class="pre">[i][j-i-1]</span></code> contains crossover information between the i-th
and the j-th stationary curves. This information is a tuple with a list
of integers representing the indexes of the proposed crossovers and an
integer indicating the total number of crossovers.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.insertion_mod.ordered_list_of_lists.GET" title="src.insertion_mod.ordered_list_of_lists.GET"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GET</span></code></a>(i, j)</p></td>
<td><p>Get the crossover information between the stationary stationary curves.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#src.insertion_mod.ordered_list_of_lists.POST" title="src.insertion_mod.ordered_list_of_lists.POST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">POST</span></code></a>(i, j, val)</p></td>
<td><p>Modify the crossover information between two stationary curves.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#src.insertion_mod.ordered_list_of_lists.add_empty_element_in_index" title="src.insertion_mod.ordered_list_of_lists.add_empty_element_in_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_empty_element_in_index</span></code></a>(i)</p></td>
<td><p>Insert an empty list in the target location.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.insertion_mod.ordered_list_of_lists.GET">
<code class="sig-name descname">GET</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">j</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.ordered_list_of_lists.GET" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the crossover information between the stationary stationary
curves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i,j</strong><span class="classifier">int</span></dt><dd><p>Indices of stationary curves. i &lt; j.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>tuple[list[int], int]</dt><dd><p>The crossover information between the chosen curves.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.insertion_mod.ordered_list_of_lists.POST">
<code class="sig-name descname">POST</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em>, <em class="sig-param"><span class="n">j</span></em>, <em class="sig-param"><span class="n">val</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.ordered_list_of_lists.POST" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the crossover information between two stationary curves.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i,j</strong><span class="classifier">int</span></dt><dd><p>Indices of stationary curves. i &lt; j.</p>
</dd>
<dt><strong>val</strong><span class="classifier">tuple[list[int], int]</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="src.insertion_mod.ordered_list_of_lists.add_empty_element_in_index">
<code class="sig-name descname">add_empty_element_in_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.ordered_list_of_lists.add_empty_element_in_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert an empty list in the target location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>index to insert an empty list.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The main effort is to shift all the known relationships when inserting
a list in between.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.propose">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">propose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em>, <em class="sig-param"><span class="n">stationary_curves</span></em>, <em class="sig-param"><span class="n">energy_curves</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.propose" title="Permalink to this definition">¶</a></dt>
<dd><p>Propose a curve to be descended.</p>
<dl>
<dt>There are three types of proposed curves to insert:</dt><dd><ol class="arabic simple">
<li><p>The already known curves from the current solution.</p></li>
<li><p>Random curves placed by selecting random times and random locations.</p></li>
</ol>
<p>3. Crossover curves, these are obtained by merging two good descended.
candidates.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd><p>Dual variable associated to the current iterate</p>
</dd>
<dt><strong>stationary_curves</strong><span class="classifier">list[<a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a>]</span></dt><dd><p>List of found stationary curves</p>
</dd>
<dt><strong>energy_curves</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>1-dimensional list of ordered floats with the respective
Benamou-Brenier energy of <code class="docutils literal notranslate"><span class="pre">stationary_curves</span></code>. See also
<a class="reference internal" href="#src.classes.curve.energy" title="src.classes.curve.energy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.classes.curve.energy()</span></code></a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a></dt><dd><p>A curve to be descended by the multistart descent method.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method will first propose all the <code class="docutils literal notranslate"><span class="pre">known_curves</span></code> from the
<code class="docutils literal notranslate"><span class="pre">current_measure</span></code>. Then it will switch between proposing <code class="docutils literal notranslate"><span class="pre">M</span></code>
consecutive crossover curves if possible and then a random curve.  The
parameter <code class="docutils literal notranslate"><span class="pre">M</span></code> is modulated by <code class="docutils literal notranslate"><span class="pre">config.crossover_consecutive_inserts</span></code>.
For the random insertion, see
<a class="reference internal" href="#src.insertion_mod.random_insertion" title="src.insertion_mod.random_insertion"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.insertion_mod.random_insertion()</span></code></a>, For crossovers, see
<a class="reference internal" href="#src.insertion_mod.find_crossover" title="src.insertion_mod.find_crossover"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.insertion_mod.find_crossover()</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.random_insertion">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">random_insertion</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.random_insertion" title="Permalink to this definition">¶</a></dt>
<dd><p>Method that proposes a random curve to be descended.</p>
<p>It selects a random number of time samples (controled via
config.insertion_max_segments) and then to select the spatial points
of the proposed curve, it uses the rejection-sampling algorithm using
as information the input dual variable w_t.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd><p>The dual variable associated to the current iterate of the algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#src.classes.curve" title="src.classes.curve"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curve</span></code></a></dt><dd><p>A random curve.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For further information, check the paper that defined this code.</p>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.rejection_sampling">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">rejection_sampling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.rejection_sampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Rejection sampling over a density defined by the dual variable.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>t</strong><span class="classifier">int</span></dt><dd><p>Index of time sample. Takes values between 0,1,…,T-1</p>
</dd>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd><p>Dual variable associated with the current iterate.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray</dt><dd><p>A random point in Ω = [0,1]^2.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.switch_at">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">switch_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve1</span></em>, <em class="sig-param"><span class="n">curve2</span></em>, <em class="sig-param"><span class="n">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.switch_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate two crossover curves by switching at given time sample</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>curve1, curve2</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd><p>Curve to crossover</p>
</dd>
<dt><strong>idx</strong><span class="classifier">int</span></dt><dd><p>Time sample index where the crossover happens.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_curve_1</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd></dd>
<dt><strong>new_curve_2</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_mod.update_crossover_memory">
<code class="sig-prename descclassname">src.insertion_mod.</code><code class="sig-name descname">update_crossover_memory</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_mod.update_crossover_memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the crossover memory by including a new stationary curve.</p>
<p>This method is meant to be called outside this module, to modify the
<code class="docutils literal notranslate"><span class="pre">global</span></code> variable crossover_memory, which is an instance of
<a class="reference internal" href="#src.insertion_mod.ordered_list_of_lists" title="src.insertion_mod.ordered_list_of_lists"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.insertion_mod.ordered_list_of_lists</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">int</span></dt><dd><p>Location to insert a new stationary curve on the known set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-src.insertion_step">
<span id="src-insertion-step-module"></span><h2>src.insertion_step module<a class="headerlink" href="#module-src.insertion_step" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="src.insertion_step.gradient_descent">
<code class="sig-prename descclassname">src.insertion_step.</code><code class="sig-name descname">gradient_descent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve</span></em>, <em class="sig-param"><span class="n">w_t</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">init_step</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">limit_stepsize</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_step.gradient_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the gradient descent to an input curve.</p>
<p>The function to minimize F(γ) is defined via the dual variable. The
Applied gradient descent is the Armijo with backtracking, with stopping
condition reached when the stepsize reaches a predefined value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>curve</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd><p>Curve to be descended.</p>
</dd>
<dt><strong>w_t</strong><span class="classifier"><a class="reference internal" href="#src.classes.dual_variable" title="src.classes.dual_variable"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.dual_variable</span></code></a></span></dt><dd><p>Dual variable associated to the current iterate.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, optional</span></dt><dd><p>A bound on the number of iterations. Defaults to
<code class="docutils literal notranslate"><span class="pre">config.multistart_descent_max_iter</span></code>.</p>
</dd>
<dt><strong>init_step</strong><span class="classifier">float, optional</span></dt><dd><p>Defines the initial step of the descent method. Defaults to
<code class="docutils literal notranslate"><span class="pre">config.multistart_descent_init_step</span></code>.</p>
</dd>
<dt><strong>limit_stepsize</strong><span class="classifier">float, optional</span></dt><dd><p>The stopping condition for the gradient descent. Defaults to
<code class="docutils literal notranslate"><span class="pre">config.multistart_descent_limit_stepsize</span></code></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>As described in the paper, the gradient descent assumes that the input
curve has negative energy: F(γ) &lt; 0.</p>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_step.insertion_step">
<code class="sig-prename descclassname">src.insertion_step.</code><code class="sig-name descname">insertion_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_step.insertion_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Insertion step &amp; optimization step executed on a target measure.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>current_measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>Target measure to apply the inserion + optimization step</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>new_measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd></dd>
<dt><strong>exit_flag</strong><span class="classifier">int</span></dt><dd><p>0 if no new inserted curve was found. 1 else.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_step.is_close_to_stationaries">
<code class="sig-prename descclassname">src.insertion_step.</code><code class="sig-name descname">is_close_to_stationaries</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">new_curve</span></em>, <em class="sig-param"><span class="n">new_curve_energy</span></em>, <em class="sig-param"><span class="n">stationary_curves</span></em>, <em class="sig-param"><span class="n">energy_curves</span></em><span class="sig-paren">)</span> &#x2192; <a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a><a class="headerlink" href="#src.insertion_step.is_close_to_stationaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a given curve is close to the set of found stationary curves.</p>
<p>The distance is measured with the <img class="math" src="_images/math/8edcd76aefbd5c6ec60e63bfb5a521444943f8a0.png" alt="H^1"/> norm, and the threshold is
set by <code class="docutils literal notranslate"><span class="pre">config.multistart_taboo_dist</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>new_curve</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code></span></dt><dd><p>Curve to check if it is close to the stationary set</p>
</dd>
<dt><strong>new_curve_energy</strong><span class="classifier">float</span></dt><dd><p>Energy of the curve to check</p>
</dd>
<dt><strong>stationary_curves</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code>]</span></dt><dd><p>List of found stationary curves</p>
</dd>
<dt><strong>energy_curves</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>Energies of the found stationary curves sorted in ascendent order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The energy_curves are used to accelerate the comparisons. To avoid
with the whole set of found stationary curves.</p>
</dd></dl>

<dl class="py function">
<dt id="src.insertion_step.multistart_descent">
<code class="sig-prename descclassname">src.insertion_step.</code><code class="sig-name descname">multistart_descent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.insertion_step.multistart_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses multistart descent to search for the global minimizing curve.</p>
<p>The multistart method corresponds to descent multiple randomly generated
curves and to record the resulting stationary point of this descent
expecting to find with this method the global minimizing curve.
Some details:</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>current_measure</strong><span class="classifier"><a class="reference internal" href="#src.classes.measure" title="src.classes.measure"><code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.measure</span></code></a></span></dt><dd><p>the current iterate of the algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>stationary_curves</strong><span class="classifier">list[<code class="xref py py-class docutils literal notranslate"><span class="pre">src.classes.curves</span></code>]</span></dt><dd><p>list of the found stationary points of the insertion step problem.</p>
</dd>
<dt><strong>energy_curves</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>respective energy of the found stationary_curves, sorted in ascending
order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>To decrease the number of descents, this method routinely checks</p></li>
</ul>
<p>if the current descended curve is close to the already known ones.
If so, it stops and discards the curve.
- The descented curves are proposed by <a class="reference internal" href="#src.insertion_mod.propose" title="src.insertion_mod.propose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">src.insertion_mod.propose()</span></code></a>
It consists of: already known curves, crossover curves, random ones.
- If a crossover curve gets too close to a stationary curve earlier
than the first check, it is not counted as an attempt.</p>
</dd></dl>

</div>
<div class="section" id="module-src.misc">
<span id="src-misc-module"></span><h2>src.misc module<a class="headerlink" href="#module-src.misc" title="Permalink to this headline">¶</a></h2>
<p>Module with miscellaneous helper methods</p>
<dl class="py class">
<dt id="src.misc.Animate">
<em class="property">class </em><code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">Animate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 63%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>alpha_channel</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>animate</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>draw</strong></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><strong>start</strong></p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><strong>subsegment</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="src.misc.Animate.alpha_channel">
<code class="sig-name descname">alpha_channel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">colors</span></em>, <em class="sig-param"><span class="n">new_times</span></em>, <em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate.alpha_channel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="src.misc.Animate.animate">
<code class="sig-name descname">animate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">i</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate.animate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="src.misc.Animate.draw">
<code class="sig-name descname">draw</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="src.misc.Animate.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="src.misc.Animate.subsegment">
<code class="sig-name descname">subsegment</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.Animate.subsegment" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt id="src.misc.animate_dual_variable">
<code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">animate_dual_variable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em>, <em class="sig-param"><span class="n">measure</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.animate_dual_variable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.misc.get_periodic_segments">
<code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">get_periodic_segments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">time</span></em>, <em class="sig-param"><span class="n">space</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.get_periodic_segments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.misc.is_inside_domain">
<code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">is_inside_domain</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.is_inside_domain" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.misc.plot_2d_time">
<code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">plot_2d_time</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">w_t</span></em>, <em class="sig-param"><span class="n">total_animation_time</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.plot_2d_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.misc.supersample">
<code class="sig-prename descclassname">src.misc.</code><code class="sig-name descname">supersample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve</span></em>, <em class="sig-param"><span class="n">max_jump</span><span class="o">=</span><span class="default_value">0.01</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.misc.supersample" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-src.operators">
<span id="src-operators-module"></span><h2>src.operators module<a class="headerlink" href="#module-src.operators" title="Permalink to this headline">¶</a></h2>
<p>Methods related to the problem’s forward operator and Hilbert spaces.</p>
<dl class="py function">
<dt id="src.operators.H_t_product">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">H_t_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em>, <em class="sig-param"><span class="n">g_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.H_t_product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.H_t_product_set_vector">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">H_t_product_set_vector</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f_t</span></em>, <em class="sig-param"><span class="n">g_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.H_t_product_set_vector" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.K_t">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.K_t_star">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t_star</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t_star" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.K_t_star_full">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">K_t_star_full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">rho</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.K_t_star_full" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.grad_K_t">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">grad_K_t</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.grad_K_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.int_time_H_t_product">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">int_time_H_t_product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em>, <em class="sig-param"><span class="n">g</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.int_time_H_t_product" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.main_energy">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">main_energy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">measure</span></em>, <em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.main_energy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.operators.overpenalization">
<code class="sig-prename descclassname">src.operators.</code><code class="sig-name descname">overpenalization</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">M_0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.operators.overpenalization" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-src.optimization">
<span id="src-optimization-module"></span><h2>src.optimization module<a class="headerlink" href="#module-src.optimization" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="src.optimization.F">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">F</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve</span></em>, <em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.F" title="Permalink to this definition">¶</a></dt>
<dd><p>The F(γ) operator, defined as F(γ) = W(γ)/L(γ).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>curve</strong><span class="classifier">DGCG.classes.curve class</span></dt><dd></dd>
<dt><strong>w_t</strong><span class="classifier">DGCG.classes.dual_variable</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>double number.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When solving the insertion step, this is the main energy to minimize.</p>
</dd></dl>

<dl class="py function">
<dt id="src.optimization.after_optimization_sparsifier">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">after_optimization_sparsifier</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em>, <em class="sig-param"><span class="n">energy_curves</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.after_optimization_sparsifier" title="Permalink to this definition">¶</a></dt>
<dd><p>Trims a sparse measure by merging atoms that are too close.</p>
<p>Given a measure composed of atoms, it will look for the atoms that are
too close, and if is possible to maintain, or decrease, the energy of
the measure by joining two atoms, it will do it.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>current_measure</strong><span class="classifier">DGCG.classes.measure class</span></dt><dd></dd>
<dt><strong>energy_curves</strong><span class="classifier">numpy.ndarray, optional</span></dt><dd><p>vector indicating the energy of the curves of the measure. To
accelerate the comparisons.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DGCG.classes.measure class</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This method is required because the quadratic optimization step is realized
by an interior point method. Therefore, it is likely to find minimums in
between two identical items instead of selecting one and discarding the
other.</p>
</dd></dl>

<dl class="py function">
<dt id="src.optimization.dual_gap">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">dual_gap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em>, <em class="sig-param"><span class="n">stationary_curves</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.dual_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>Dual gap in the current measure.</p>
<p>The dual gap computed using the Lemma formula for it. It recieves as
input the current iterate of the algorithm, together with a list of
curves ordered output of the taboo search. This list of curves is ordered
by the energy F(γ), therefore the first member is the obtained minimizer
of the insertion step problem.
————————–
Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>current_measure (measure class):</dt><dd><p>The current iterate of the algorithm.</p>
</dd>
<dt>stationary_curves (list of curves class):</dt><dd><p>A list of curves output of the taboo search. It is assumed that
the curves are ordered by increasing F(γ) values.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Output:</dt><dd><dl class="simple">
<dt>dual_gap (float):</dt><dd><p>The dual gap computed in the current_measure folowing formula (??)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.optimization.grad_F">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">grad_F</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">curve</span></em>, <em class="sig-param"><span class="n">w_t</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.grad_F" title="Permalink to this definition">¶</a></dt>
<dd><p>The gradient of the F operator, ∇F(γ).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>curve</strong><span class="classifier">DGCG.classes.curve class</span></dt><dd></dd>
<dt><strong>w_t</strong><span class="classifier">DGCG.classes.dual_variable</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>double number.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the gradient to minimize F(γ).</p>
</dd></dl>

<dl class="py function">
<dt id="src.optimization.gradient_descent">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">gradient_descent</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em>, <em class="sig-param"><span class="n">init_step</span></em>, <em class="sig-param"><span class="n">max_iter</span><span class="o">=</span><span class="default_value">100</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.gradient_descent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.optimization.slide_and_optimize">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">slide_and_optimize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.slide_and_optimize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.optimization.solve_quadratic_program">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">solve_quadratic_program</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.solve_quadratic_program" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="src.optimization.to_positive_semidefinite">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">to_positive_semidefinite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">Q</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.to_positive_semidefinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a symmetric matrix and returns a positive semidefinite projection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Q</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>symmetric matrix</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy.ndarray, symmetric positive semidefinite matrix.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="src.optimization.weight_optimization_step">
<code class="sig-prename descclassname">src.optimization.</code><code class="sig-name descname">weight_optimization_step</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">current_measure</span></em><span class="sig-paren">)</span><a class="headerlink" href="#src.optimization.weight_optimization_step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-src">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-src" title="Permalink to this headline">¶</a></h2>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, K. Bredies, M. Carioni, S. Fanzon, F. Romero-Hinrichsen.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
  </body>
</html>